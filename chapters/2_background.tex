\chapter{Background}
In this chapter we will describe the languages that \fshark{} depends on,
including a short introduction to the OpenCL framework.

\subsection*{Parallel programming in Futhark}
GPU programming is in principle easily available for everyone. As long as the user has access
to a GPU and a reasonable PC for developing software, it just takes a bit of
effort and reading to get started with CUDA, OpenCL or similar programming.
Realistically however, it takes much more than just a little effort to start writing
one's own GPU programs.

Take for instance the function $f(x) = ax+y$. In figure \ref{fig:cudasaxpy} we see the
function implemented as a CUDA program. In this program, we are defining the
kernel \texttt{saxpy} itself, and also manually copying data back and forth
between the GPU.
Compared to the same program written in Futhark (figure \ref{fig:futsaxpy}.)

Whereas the CUDA kernel needs to check whether the current thread is outside of
the bounds of the input data, the equivalent kernel in Futhark is simply a
declaration of it's function. Also, the Futhark version does not bother with
getting array elements by the current thread ID.

In the main function itself, the initial lists are generated by functions, and
the user doesn't have to allocate space on neither the computer \textit{host},
or the GPU \textit{device}.
The hard work is done by a Futhark SOAC, which is eventually compiled into a
kernel  %% MERE MERE MERE

Of course, Futhark is compiled into either C- or Python code that does indeed
contain memalloc calls, GPU kernels with bounds checking, and so on, but that
part is very well hidden from the Futhark programmers themselves.
All in all, writing effective GPU programs becomes much more accessible when it's
possible to do in a declarative manner, like Futhark, without also having to
the minute details that comes with GPU computations.
\begin{figure}
  \centering
\begin{minted}{cpp}
  #include <stdio.h>

__global__
void saxpy(int n, float a, float *x, float *y)
{
  int i = blockIdx.x*blockDim.x + threadIdx.x;
  if (i < n) y[i] = a*x[i] + y[i];
}

int main(void)
{
  int N = 1<<20;
  float *x, *y, *d_x, *d_y;
  x = (float*)malloc(N*sizeof(float));
  y = (float*)malloc(N*sizeof(float));

  cudaMalloc(&d_x, N*sizeof(float)); 
  cudaMalloc(&d_y, N*sizeof(float));

  for (int i = 0; i < N; i++) {
    x[i] = 1.0f;
    y[i] = 2.0f;
  }

  cudaMemcpy(d_x, x, N*sizeof(float), cudaMemcpyHostToDevice);
  cudaMemcpy(d_y, y, N*sizeof(float), cudaMemcpyHostToDevice);

  // Perform SAXPY on 1M elements
  saxpy<<<(N+255)/256, 256>>>(N, 2.0f, d_x, d_y);

  cudaMemcpy(y, d_y, N*sizeof(float), cudaMemcpyDeviceToHost);

  cudaFree(d_x);
  cudaFree(d_y);
  free(x);
  free(y);
}
\end{minted}
  \caption{$ax + y$ in CUDA}
  \label{fig:cudasaxpy}
\end{figure}

\begin{figure}
  \centering
  \begin{lstlisting}[language=Futhark]
    let saxpy (a : f32) (x : f32) (y : f32) : f32 =
      a*x+y

    let main =
      let N = 1<<20
      let a = 2f32
      let xs = replicate N 1f32
      let ys = replicate N 2f32
      let ys = map2 (saxpy a) xs ys
      in ys
  \end{lstlisting}
  \caption{$ax+y$ in Futhark}
  \label{fig:futsaxpy}
\end{figure}

\subsection*{\fsharp{}}
\fsharp{} is a relatively young .NET-based language, first released in 2003.
It is a strongly-typed multiple-paradigm language, with a syntax that is
primarily functional, resembling OCaml.
Although \fsharp{} is not as widely used as \csharp{}, \texttt{Java} and the
like, it is currently experiencing increasing adaptation among
developers\cite{citeme}.
Besides supporting multiple paradigms and a reasonable subset of functional
langauge features (such as pattern matching), \fsharp{}s primary strength is
it's interoperability with the rest of the .NET ecosystem. Like \csharp{},
\fsharp{} programs are compiled into Microsoft's \texttt{Common Intermediate
  Langauge}, and executed using Microsoft's \texttt{Common Language Runtime}.

Therefore, \fsharp{} programs have full access to the standard .NET library,
just as it can also readily import and use classes and methods from arbitrary
\csharp{} libraries.

For \fshark{}, \fsharp{} has been selected as a source language for several
reasons.
First, most of \fsharp{}s syntax is readily translatable into Futhark syntax, as
long as the programmer stays away from using any of \fsharp{}s non-functional
constructs, like \texttt{async} or it's object oriented features.
Second, as \fsharp{} effortlessly interoperates with \csharp{} programs, and
\csharp{} has plenty of OpenCL libraries available, we can write imperative
OpenCL-powered programs in \csharp{}, for use in \fsharp{} projects.
%% written example


\section*{\csharp{}}
\csharp{} 
\csharp{} 
\csharp{} 
\csharp{} 

\clearpage
\subsection*{Futhark}
Quoting from Futhark's own homepage,
\begin{formal}
  Futhark is a small programming language designed to be compiled to efficient parallel code. It is a statically typed, data-parallel, and purely functional array language in the ML family, and comes with a heavily optimising ahead-of-time compiler that presently generates GPU code via OpenCL, although the language itself is hardware-agnostic.
\end{formal}
So far, plenty of handwritten GPU benchmark programs implemented in CUDA et al,
has been ported to Futhark, with significant performance gains as a result.
\cite{citesomething}. With these results in mind, it makes sense to start
implementing other parallelizable algorithms and programs in Futhark. However,
in the grand scheme of things, Futhark is still a relatively obscure programming
language, and is almost solely used in academic settings.

With Futhark being a purely functional programming language, it has very few
imperative language constructs available, and the few that it has, like
in-place updates, are merely syntactic sugar for other existing library function calls.

As Futhark's main functionality is generating OpenCL kernels, it is in principle
possible to compile Futhark programs for any language that are able to interface
with the OpenCL API.

%err, måske flytte eller skrive om
As a target language for \fsharp{} translations,
Futhark is ideal as we can identify and relatively easily translate a subset
of the \fsharp{} language to equivalent Futhark code, as the syntax itself is
very similar. Even though \fsharp{} also allows plenty of imperative and object
oriented programming,
\fshark{} blocks the user from using these constructs, by failing at \fshark{}
compile time.

% måske tilføje noget om unsafe

\section*{A primer on OpenCL}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis"
%%% End:
