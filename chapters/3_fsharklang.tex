\chapter{The \fshark{} language}
\label{chap:fsharklanguage}

HERE IS A NICE INTRODUCTION.
% introduction

\begin{figure}
  \centering
  \begin{tabular}{@{}lclr}
    $t$ & $::=$ & $\texttt{int8}~|~\texttt{int16} ~|~ \texttt{int} ~ |~\texttt{int64} $ & (Integers) \\
        & $|$   & $\texttt{uint8} ~ | ~\texttt{uint16} ~|~\texttt{uint} ~|~\texttt{uint64} $ & (Unsigned integers) \\
        & $|$   & $\texttt{single} ~| ~\texttt{double}$ & (Floats) \\
        & $|$   & $\texttt{bool}$ & (Booleans) \\
        & $|$   & $(t_0 * \ldots * t_n)$ & (Tuples) \\
        & $|$   & $\{id_0:t_0;~\ldots;~id_n:t_n\}$ & (Records) \\
        & $|$   & $t~\mathtt{array}$& (Arrays) \\
    \\
  \end{tabular}
  \caption{\fshark{} types}
\end{figure}

\begin{figure}
  \centering
  \begin{tabular}{@{}lclr}
    $k$ & $::=$ & $n\lit{y}~|~n\lit{s}~|~n~|~n\lit{L}$ & (8-, 16-, 32- and 64 bit signed integers) \\
        & $|$   & $n\lit{uy}~|~n\lit{us}~|~n~|~n\lit{UL}$ & (8-, 16-, 32- and 64 bit unsigned integers) \\
        & $|$   & $d\lit{f}~|~d $ & (Single and double precision floats) \\
        & $|$   & $true~|~false$ & (Boolean) \\
        & $|$   & $(k_0 ,~\ldots ,~k_n)$ & (Tuple) \\
        & $|$   & $\{id_0=k_0;~\ldots;~id_n=k_n\}$ & (Record) \\
        & $|$   & $[\vert k_0 ; \ldots ; k_n\vert]$ & (Array) \\
    \\
  \end{tabular}
  \caption{\fshark{} literals}
\end{figure}

\begin{figure}
  \centering
  \begin{tabular}{@{}lclr}
    $p$ & $::=$ & $id$ & (Name pattern) \\
        & $|$   & $(p_0, \ldots, p_n)$ & (Tuple pattern) \\
  \end{tabular}
  \caption{\fshark{} patterns}
\end{figure}

\begin{figure}
  \centering
  \begin{tabular}{lclr}
    $e$ & $::=$ & $(e)$ & Expression in parens \\
        & $|$   & $k$ & Constant \\
        & $|$   & $v$ & Variable \\
        & $|$   & $(e_0,~\ldots,~e_n)$ & (Tuple expression) \\
        & $|$   & $\{\texttt{id}_0=e_0 ; \ldots ; \texttt{id}_n=e_n\}$ & (Record expression) \\
        & $|$   & $[\vert e_0 ; \ldots ; e_n\vert]$ & (Array expression) \\
        & $|$   & $e_1 \odot e_2$ & (Binary operator) \\
        & $|$   & $-e$ & (Prefix minus) \\
        & $|$   & \texttt{not} $e$ & (Logical negation) \\
        & $|$   & \texttt{if} $e_1$ \texttt{then} $e_2$ \texttt{else} $e_3$ & (Branching) \\
        & $|$   & $v.[e_0] \ldots .[e_n]$ & (Array indexing) \\
        & $|$   & $v$.\texttt{id} & (Record indexing) \\
        & $|$   & $v_0.v_1$ & (Module indexing) \\
        & $|$   & \texttt{let} $p = e_1$ \texttt{in} $e_2$ & (Pattern binding) \\
        & $|$   & $v~e_0~\ldots e_n$ & (Function call) \\
        & $|$   & $\mathtt{fun}~p_0~\ldots~p_n~\mathtt{->}~e$ & (Anonymous function) \\

    \\
  \end{tabular}
  \caption{\fshark{} expressions}
\end{figure}

\begin{figure}
  \centering
  \begin{tabular}{lclr}
    $fun$ & $::=$ & \texttt{[<FSharkEntry>]} $\texttt{let}\ v\ (v_1 : t_1)\ \ldots\ (v_n : t_n) : t = e$ & \\
        & $|$   & $\texttt{let}\ v\ (v_1 : t_1)\ \ldots\ (v_n : t_n) : t' = e,$ & \\
        &       & \hspace{1em} \textit{(for any $i \in {1..n}$, $t_i$ is not a tuple)} \\
    \\

    $typealias$ & $::=$ & $\texttt{type}\ v\ = t $& \\
    $module$ & $::=$ & $\texttt{module}\ v = prog'\ progs'$ & \\
    \\
    $prog$ & $::=$ & $module\ prog$ & \\
           & $|$   & $prog'\ prog$  & \\
           & $|$   & $\epsilon$     & \\

    $prog'$ & $::=$ & $typealias$   & \\
            & $|$   & $fun$ & \\

    $progs'$ & $::=$ & $prog'\ progs'$   & \\
             & $|$   & $\epsilon$ & \\
  \end{tabular}
  \caption{\fshark{} statements}
\end{figure}

\clearpage

\subsection*{\fsharp{} operators available in \fshark{}}
The \fsharp{} subset chosen for \fshark{} is described in this subsection.
\begin{figure}[h]
  \centering
\begin{description}
\item[Arithmetic operators]\hfill\\
  The set of supported arithmetic operators is addition (\texttt{+}),
  binary subtraction and unary negation (\texttt{-}), multiplication
  (\texttt{*}), division (\texttt{/}) and modulus (\texttt{\%}).
  
\item[Boolean operators]\hfill\\
  \fshark{} currently supports logical AND (\texttt{\&\&}), logical OR
  (\texttt{$||$}), less- and greater-than (\texttt{<}, \texttt{>}), less- and
  greater-or-equal (\texttt{<=}, \texttt{>=}), equality (\texttt{=}),
  inequality (\texttt{<>}) and logical negation (\texttt{not}).

\item[Special operators]\hfill\\
  \fshark{} also supports some of \fsharp{}s syntactic sugar. These operators
  might not have direct Futhark counterparts, but their applications can be
  rewritten in Futhark for equivalent functionality.
  The supported operators are back- and forward pipes (\texttt{<|} and
  \texttt{|>}), and the range operator ($e_0$ \texttt{..} $e_1$), which
  generates the sequence of numbers in the interval $[e_0,e_1]$. Note that in
  \fshark{}, the range operator must be used inside an array as so
  \texttt{[|$e_0$..$e_1$|]} so we adhere to using arrays and not lists in our
  \fshark{} programs.
\end{description}
  \caption{\fshark{} operators}
  \label{fig:fsharkops}
\end{figure}
Note that all of these operators are overloaded and defined for all integer
and floating point types in \fsharp{}.



\subsection*{\fsharp{} standard library functions available in \fshark{}}
\fshark{} supports a subset of the \fsharp{} standard library. These are
functions that are imported in \fsharp{} modules by default.

\begin{figure}[h]
  \centering
\begin{description}
\item[\texttt{id}]\hfill\\
  The identity function.

\item[Common math function]\hfill\\
  The square root function (\texttt{sqrt}), the absolute value (\texttt{abs}),
  the natural exponential function (\texttt{exp}), the natural- and the decimal
  logarithm (\texttt{log} and \texttt{log10}).
  
\item[Common trigonometric functions]\hfill\\
  Sine, cosine and tangent functions (both standard and hyperbolic):
  \texttt{sin}, \texttt{cos}, \texttt{tan}), \texttt{sinh}, \texttt{cosh} and \texttt{tanh}.
  Also one- and two-argument arctangent: \texttt{atan} and \texttt{atan2}.

\item[Rounding functions]\hfill\\
  \fshark{} supports all of \fsharp{}s rounding functions:
  \texttt{floor}, \texttt{ceil}, \texttt{round} and \texttt{truncate}.
  
\item[Number convertion functions]\hfill\\
  \fshark{} supports all of \fsharp{}s number convertion functions.
  For all the following functions $t$, $t e = e', e : t_0, e' : t$, barring
  exceptions like trying to convert a too large 64-bit integer into a 32-bit
  integer.

  The convertion functions available are \texttt{int8}, \texttt{int16}, \texttt{int}, \texttt{int64}, \texttt{uint8}, \texttt{uint16},
  \texttt{uint}, \texttt{uin64}, \texttt{single}, \texttt{double}, \texttt{bool}.
  
\item[Various common number functions]\hfill\\
  \texttt{min}, \texttt{max}, \texttt{sign} and \texttt{compare}.
\end{description}
  \caption{\fshark{} operators}
  \label{fig:fsharkfuns}
\end{figure}

Currently, bitwise operators like bitwise-AND and bitwise-OR are missing, but
they should be relatively simple to add to the \fshark{} subset, by adding them
to the set of supported operators in the \fshark{} compiler.

\subsection*{On the \fsharp{} subset selected for \fshark{}}
For selecting the \fsharp{} subset to support in \fshark{}, I chose to look at
what functions that were included in \fsharp{}'s prelude. That is, the
functions that are available in an \fsharp{} program without having to
\texttt{open} their containing module first.
Fortunately, \fsharp{} opens several modules by default of which I only
needed to look in two different ones, to be able to support a reasonable amount
of \fsharp{} built-ins in \fshark{}.

The primary module used in my supported \fsharp{} subset is the module
\texttt{FSharp.Core.Operators}.
This module contained not only the standard arithmetic described in figure
\ref{fig:fsharkops}, but also most\footnote{except for some convertion
  functions, found in \texttt{FSharp.Core.ExtraTopLevelOperators}} of the functions shown in the figure \ref{fig:fsharkfuns}.
Except for \texttt{unit} type functions like \texttt{failwith}, \texttt{exit}
and \texttt{async}, most of the functions and operators
\texttt{FSharp.Core.Operators} have direct counterparts in Futhark's prelude,
with equivalent functionality: All except for four of operators and functions chosen for
\fshark{} are in fact implemented in Futhark's \texttt{math.fut} library.
It was therefore aan obvious decision to support these functions and operators in
\fshark{}.

However, for the remaining four functions, that didn't have equivalents in
Futhark's \texttt{math.fut}, their function calls are replaced with their
identities instead.
In example, whereas the \fshark{} code
\begin{minted}{ocaml}
  exp x
\end{minted}
is written in Futhark as 
\begin{lstlisting}[language=Futhark]
  exp x
\end{lstlisting}
because the exp function is also available in \texttt{math.fut}, the \fshark{}
code
\begin{minted}{ocaml}
  cosh x
\end{minted}
is rewritten as the full hyperbolic sine function instead, as so
\begin{lstlisting}[language=Futhark]
  ((exp x) + (exp (-x))) / 2.0
\end{lstlisting}
These rewritings are not pretty to look at from a programmer's perspective, but
\fshark{}s Futhark code is not meant to be read by humans anyhow.

(MAYBE INVESTIGATE WHETHER INLINING THESE HAS PERFORMANCE PENALTIES) 

% i could have also supported limited imports

\subsection*{The correctness of the \fshark{} subset.}
When transpiling code from one language to another, it is absolutely vital that
the programmer can trust, that the resulting code in the target language is
semantically equivalent to the source code.
In \fshark{}s case, it means that any program written using the \fshark{}
subset, must have the same result no matter whether it is run natively as
\fsharp{} code, or it is run as \fshark{} compiled Futhark code.

I.e., one could imagine a programming language which had defined the function
\texttt{log} not as the natural logarithm, but instead the binary logarithm. In
such a case, the translation from that language to Futhark would still go
without a hitch, and without any type errors to hint at the impending
catastrophe.
However, the native result with the Futhark result would be wildly different.

To ensure that every operator and function in the \fshark{} subset has
equivalent results, no matter whether the \fshark{} code is run as native
\fsharp{} code, or compiled into Futhark, I have written a test suite with unit
tests for each element in the \fsharp{} subset. 


(THESE ARE NOT ACTUALLY DONE YET)
(Are unit tests enough?)

% all convertion functions pass through i64. this might be a mistake, as real
% supports f32 to f64

% thoughts on correctness of translations
% testing correctness of these translations


% why block people from using Array.map and direct them to SOACs instead ( )

\chapter{FSharkPrelude}
Besides defining an \fsharp{} subset suitable for Futhark translation, it was
also imperative to create a library of SOACs and array functions for \fshark{},
to make it possible to write programs with parallel higher-order array
functions.

Similarly to how the subset of math functions chosen from \fsharp{} to include in
the \fshark{} was chosen, the SOACs and array function included in the
\texttt{FSharkPrelude} has been picked directly from the Futhark libraries
\texttt{futlib/array.fut} and \texttt{futlib/soacs.fut}. The \texttt{FSharkPrelude} doesn't
discriminate between array functions and SOACs, as maintaining and importing two
different prelude files in \fshark{} was needlessly complicated.

The \texttt{FSharkPrelude} consists of functions which are directly named after
their Futhark counterparts, and have equivalent functionality.
This prelude, together with the \fshark{} subset, is what makes up the \fshark{} language.
When \fshark{} developers are writing modules in \fshark{}, they are guaranteed
that their \fshark{} programs has the same results, no matter whether their
programs are executed like native \fsharp{} code, or compiled and executed as
Futhark.

The \texttt{FSharkPrelude} versions of Futhark functions are defined in three
different ways.
\begin{enumerate}
  \item Functions like the SOAC \texttt{map} and the array function
    \texttt{length} have direct \fsharp{} equivalents, and are therefore
    implemented as calls to \texttt{Array.map} and \texttt{Array.length}
    respectively.
    For \texttt{map} for example, we have the following definition:
    \begin{minted}{fsharp}
let Map f aa = Array.map f aa
    \end{minted}

  \item Some Futhark SOACs, like \texttt{reduce}, takes a neutral element as one of the
    arguments in their function calls, whilst their \fsharp{} counterparts
    (\texttt{Array.reduce}) does only take an operator and an array as
    arguments.
    To define the \fshark{} SOAC so that it is equivalent to the Futhark
    version, it has been defined as so:
\begin{minted}{fsharp}
let Reduce (op: 'a -> 'a -> 'a) (neutral : 'a) (xs : 'a array) =
  let xs' = Array.append [|neutral|] xs
  in Array.reduce op xs'
\end{minted}

    Other functions, like the \texttt{map} functions which takes multiple arrays as
    arguments, require a bit of assembly first. For those \texttt{map} functions,
    we zip the arguments before using \texttt{Array.map} as usual:
\begin{minted}{fsharp}
let Map5 f aa bb cc dd ee =
  let curry f (a,b,c,d,e) = f a b c d e
  let xs = Zip5 aa bb cc dd ee
  in Array.map (curry f) xs
\end{minted}

    \item Lastly, some functions does not have \fsharp{} counterparts. In
      example, we implement \texttt{scatter} using a for-loop:
\begin{minted}{fsharp}
let Scatter (dest : 'a array) (is : int array) (vs : 'a array) : 'a array =
  for (i,v) in Zip is vs do
    dest.[i] <- v
  dest
      \end{minted}
\end{enumerate}
The complete list of available SOACs and array functions is available in
appendix \ref{appendix:soacs}.

Note that calls to \texttt{FSharkPrelude} functions are caught and exchanged for
Futhark functions during the \fshark{} compilation, as described in sec \ref{kig
  kig}.

% descriptions


% WHY ALL OF THIS
\subsection*{Why is FSharkPrelude part of the \fshark{} langauge?}
Several of Futhark's SOACs, such as \texttt{map}, already has \fsharp{}
versions that are directly equivalent.

But there are several issues with just letting the \fshark{} programmer use 
But many of these \fsharp{} functions are
contained in 
HER KOMMER DER MERE

% 1) it would be awkward to maintain a whitelist of accepted library functions,
% instead of simply handing the developer a gated library.
% 1½) uncomfortable to be told function is not supported at runtime 

% 2) some Array functions have subtle differences compared to their
% futhark counterparts. In example, reduce doesn't take a neutral element which
% Futhark's reduce does.

% 3)


% note; FSharkPrelude cannot detect bad operators in reduce. non-commutative ops
% in reduce goes bad when parallel, så deeeeeet


% some implementations, like ZipN, are probably criminally ineffective.

\subsection*{Arguing for Futhark-equivalent functionality}
% correctness


\section{Arrays in \fsharp{} versus in Futhark}
\subsection*{array handling in Futhark vs in \fsharp{}}

\subsection*{how SOACs are executed in \fshark{} vs. in Futhark}
touch on complexity and so forth
biggest issue is that Futhark C code works inplace, while these versions
returns copies of the functions
 
\subsection*{Translating \fsharp{} arrays to Futhark arrays}
brush up on Futhark array implementation

brush up on fsharp arrays, specifically jagged arrays and how they are
implemented (pointers to pointers to arrays)

\section{Converting fsharp arrays to futhark arrays, and back again}

description of the algorithm

the complexity of the algorithm

\subsection*{An alternative solution (FSharkArrays)}
How they work

How they would alleviate the problem

Why they weren't chosen anyhow (hint; needing to pepper FSharkArray all over
code, would stand in way of idiomatic FSharp style)
%

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis"
%%% End: