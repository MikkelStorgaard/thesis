\chapter{The FShark Compiler and Wrapper}
\section*{Introduction}
\label{sec:fsharkcompiler}
Parsing and building a regular F\# program is trivial when using official build tools like
\texttt{msbuild} or \texttt{fsharpc}.
But in the case of FShark, we are not interested in the final result from the
F\# compiler, but merely its half-finished product.

As the F\# Software Foundation offers the official F\# Compiler as a freely
available NuGet package for F\# projects, we can use this package
\texttt{FSharp.Compiler.Services} to parse the entire input FShark program and
give us a Typed Abstract Syntax Tree of the FSharp expressions therein.

FIGURE HERE OF THE USUAL FSHARP COMPILATION 

As the F\# Software Foundation actively encourages developers to create projects
using the F\# compiler library, they have published the collected F\# compiler
as a NuGet package, alongside a tutorial\ref{fsharptutorial}on the usage of the
various compiler parts.

For FShark, the Compiler Services package is used to compile a Typed Abstract
Syntax Tree from a valid FShark source code file, which we then
convert into- and print as a valid Futhark program.
The Typed Abstract Syntax Tree is merely an AST that already has tagged all the
contained expressions with their respective types.

We'll start with a detailed explanation of the FShark Compiler Pipeline.

\subsection{The FShark Compiler Pipeline in practice}
To examine the compiler pipeline in action, we'll go through the motions with
the small example program displayed in figure \ref{fig:fsharkusageexample}.
We begin by constructing an instance of the FSharkWrapper. It has the following
mandatory arguments:

\begin{description}
\item[\texttt{libName}]\hfill\\
  This is the library name for the FShark program. In the final Futhark
  \texttt{.cs} and \texttt{.dll} files, the main class will have the same name
  as the \texttt{libName}. This doesn't really matter if FShark is just used
  as a JIT compiler, but it's good to have a proper name if the user only wants
  to use the compiler parts of FShark.

\item[\texttt{tmpRoot}]\hfill\\
  The FShark compiler works in its own temporary directory. This argument must
  point to a directory where F\# can write files and execute subprocesses
  (Futhark- and C\# compilers) which also has to write files.
  
\item[\texttt{clooPath} and \texttt{monoOptionsPath}]\hfill\\
  The C\# compiler needs the \texttt{Cloo}- and the \texttt{Mono Options}
  libraries available for the compilation, and the finished FShark .dll file
  also needs these two libraries available. To ensure their availability, the
  FSharkWrapper requires these paths at the beginning of the process, so it can
  pass them on later in the process.

\item[\texttt{preludePath}]\hfill\\
  The FShark compiler needs the FShark prelude available to compile FShark
  programs. 

\item[\texttt{openCL}]\hfill\\
  Although Futhark (and therefore FShark) is most effective on OpenCL-enabled
  computers, the benchmarks in \ref{sec:benchmarks} still show a significant
  speed increase for non-OpenCL Futhark over native F\# code.
  Therefore, FShark is also available for non-OpenCL users. Use this flag to
  tell FShark whether Futhark should compile C\# with or without OpenCL.
  
\item[\texttt{unsafe}]\hfill\\
  For some Futhark programs, the Futhark compiler itself is unable to tell
  whether certain array operations or SOAC usages are safe, and will stop the
  compilation, even though the code should (and does) indeed work.
  To enable these unsafe operations, pass a \texttt{true} flag to the compiler.
\end{description}

Now, we can pass a source file to the FShark wrapper, compile\footnote{See
  subsection \ref{subsec:fsharkwrappercompiles}} it and load it into the FShark wrapper object.

To use the compiled FShark function, we must first wrap our designated input in
an \texttt{obj array}. In this case, our chosen FShark function takes one
argument, an \texttt{int array}. We define this array, and construct an argument
array containing this single element. If the FShark function takes two
arguments, we define an input \texttt{obj array} with two elements, and so
forth.
It is important to declare the input array as an \texttt{obj array}. Otherwise,
F\#s own type checker might very well faultily infer the input array as
something else. In this particular case, \texttt{input} would've been inferred
as being an \texttt{int array array}, until we declared its type specifically.

We then invoke the desired function through the wrapper. As all
reflection-invoked functions return a value of type \texttt{obj}, we need to
downcast this object manually.
In this example, we use F\#s downcast operator \texttt{(:?>)} to declare the
return value as an \texttt{int array}. The actual return type is always the same as the
return type declared in the source FShark file.

\subsection{When FShark Wrapper Compiles}
\label{sec:fsharkwrappercompiles}
The general way to compile and load an FShark program into the FShark Wrapper,
is by adding FShark source files to the wrapper object by calling the
\texttt{AddSourceFile} method, and followingly calling the \texttt{CompileAndLoad}
method. Although the FShark wrapper also offers other methods of loading and
compilation, this is the primary one, as it initiates the entire FShark
compilation pipeline.

When calling \texttt{CompileAndLoad}, the supplied FShark source files are
concatenated into one long source file, and written to a temporary location.
An FSharpChecker is then initialized, so we can parse and type check the
concatenated source code. The FSharpChecker is a class exported by the FSharp
Compiler Services, and is a class that lets developers use part of the F\#
compilation pipeline at runtime.

We supply the FSharpChecker with the path to our precompiled FSharkPrelude
assembly, and then call its \texttt{ParseAndCheckProject} method on to receive
an assembly value, which contains the complete Typed Abstract Syntax Tree of our
FShark program, in the form of an \texttt{FSharpImplementationFileDeclaration}.

If the FShark developer followed the guidelines to write a well-formed FShark
module, the main declaration of the program, the
\texttt{FSharpImplementationFileDeclaration}, should contain a single
\texttt{FSharpEntity}, which in turn contains all the remaining declarations in
the program.

\subsubsection{The declaration types within F\#'s Typed AST}
The \texttt{FSharpImplementationFileDeclaration} type has three union cases.
\begin{description}
\item[\texttt{InitAction of FSharpExpr}] \hfill\\
  \texttt{InitAction}s are \fsharpexpr{}s that are executed at the
  initialization of the containing entity. These are not supported in FShark.

\item[\texttt{Entity of FSharpEntity * FSharpImplementationFileDeclaration list}]\hfill\\
  An \texttt{Entity} is the declaration of a type or a module. In the case of
  FShark, three different kinds of entities are supported:
  \begin{description}
  \item[FSharpRecords] are standard record types, and can be translated to
    Futhark records with ease.
    This entity has an empty \texttt{FSharpImplementationFileDeclaration list}.
  \item[FSharpAbbreviations] are type abbreviations, and are easily translated
    into Futhark type aliases.
    This entity has an empty \texttt{FSharpImplementationFileDeclaration list}.
  \item[FSharpModules] are named modules which contains subdeclarations.
    In this case, we retrieve the subdeclarations from the \texttt{FSharpImplementationFileDeclaration list}.
    The FShark compiler supports building FShark modules, but current
    limitations demands that modules are flattened when compiled to Futhark.
    This also means that function name prefixes in function calls are stripped
    when compiled to Futhark.
  \end{description}
\item[\texttt{MemberOrFunctionOrValue of \\ FSharpMemberOrFunctionOrValue *
    FSharpMemberOrFunctionOrValue list list * FSharpExpr}]\hfill\\
  F\# doesn't differ between functions and values, which means that a function
  is merely a value with arguments.
  A pattern matched \texttt{MemberOrFunctionOrValue} value has the form
  \texttt{MemberOrFunctionOrValue (v, args, exp)}, where \texttt{v} contains the
  name and the type of the variable.
  If the \texttt{args} list is empty, \texttt{v} is simply a variable. If not,
  \texttt{v} is a function. \texttt{exp} contains the \fsharpexpr{} that
  \texttt{v} is bound to. An \fsharpexpr{} can be anything from a numeric
  constant to a very long function body.
\end{description}

\subsection{FSharp-to-FSharkIL rules}
INTRODUCTION HERE
For these translations, we will disregard that all \fsharpexpr{}s are union
cases of the F\# data type \texttt{BasicPatterns}.

\begin{figure}
  \centering
\begin{tabular}{@{}l c l c l c l}% to \linewidth {l c X}
  $\evals{Int8}$ & $=$ & $\lit{Prim Int FInt8} $ & ~~~~~ & 
  $\evals{Int16}$ & $=$ & $\lit{Prim Int FInt16}$
  \\
  $\evals{Int32}$ & $=$ & $\lit{Prim Int FInt32} $ & ~~~~~ & 
  $\evals{Int64}$ & $=$ & $\lit{Prim Int FInt64} $
  \\
  $\evals{UInt8}$ & $=$ & $\lit{Prim UInt FUInt8} $ & ~~~~~ & 
  $\evals{UInt16}$ & $=$ & $\lit{Prim UInt FUInt16} $ 
  \\
  $\evals{UInt32}$ & $=$ & $\lit{Prim UInt FUInt32} $ & ~~~~~ & 
  $\evals{UInt64}$ & $=$ & $\lit{Prim UInt FUInt64} $ 
  \\
  $\evals{Single}$ & $=$ & $\lit{Prim Float FSingle} $ & ~~~~~ & 
  $\evals{Double}$ & $=$ & $\lit{Prim Float FDouble} $ 
  \\
  $\evals{\tau []}$ & $=$ & $\lit{FSharkArray }\evals{\tau}$ & ~~~~~ & 
  $\evals{(\tau_0 \times \ldots \times \tau_n)}$ & $=$ & $\lit{FSharkTuple}~\evals{\tau_0},\ldots,\evals{\tau_n}$ \\ ~ \\
\end{tabular}

INSERT NOTE ON RULE FOR TUPLE ('a [] * long [])

\caption{F\# (.NET) types to FSharkIL types}
\end{figure}


\begin{figure}
  \centering
  \begin{tabular}{@{}l c l c l c l c l c l}% to \linewidth {l c X}
  %$\evals{Const(obj, \tau)}$ & $=$ & $\lit{Const}(obj,}\evals{\tau}}\lit{)}$ & ~~~~~ &
%  $\evals{i}$ & $=$ & $i$ & ~~~~~ & 
%  $\evals{f}$ & $=$ & $f$ \\
  $\evals{c}$ & $=$ & $\id{ascii}(c)$ & ~~~~~ & 
  $\evals{\lit{tt}}$ & $=$ & $\lit{true}$ & ~~~~~ & 
  $\evals{\lit{ff}}$ & $=$ & $\lit{false}$ \\ ~ \\
\end{tabular}
  \caption{FShark SOACs}
\end{figure}





\begin{figure}
  \centering
    \begin{minted}[linenos,breaklines]{fsharp}
module FSharkExample
open FShark.Main

[<EntryPoint>]
let main argv =
  let wrapper = 
    new FSharkWrapper(
      libName="ExampleModule",
      tmpRoot="/home/mikkel/FShark",
      clooPath="/home/mikkel/Cloo.clSharp.dll",
      monoOptionsPath="/home/mikkel/Mono.Options.dll",
      preludePath= "/home/mikkel/Documents/fshark/FSharkPrelude/bin/Debug/FSharkPrelude.dll",
      openCL=true,
      unsafe=true
      )

  wrapper.AddSourceFile "../../srcs/ExampleModule.fs"
  wrapper.CompileAndLoad
  let xs = [|1;2;3;4|]
  let input = [|xs|] : obj array
  let xs' = wrapper.InvokeFunction "MapPlusTwo" input :?> int array
  printfn "Mapping (+2) over %A gives us %A" xs xs'
  0
    \end{minted}
  \caption{An F\# program using FShark}
  \label{fig:fsharkusageexample}
\end{figure}

\begin{figure}
  \centering
  \begin{minted}[xleftmargin=5pt,linenos]{fsharp}
    module ExampleModule
    open FSharkPrelude

    module SomeValues =
      let Four : int = 4

      let SomePlus (x : int) (y : int) : int = x + y

    [<FSharkEntry>]
    let TimesTwo (x : int) : int =
      SomeValues.SomePlus x x
  
    [<FSharkEntry>]
    let MapPlusTwo (xs : int array) : int array =
      Map ((+)2) xs

    let PlusSeven (x : int) : int =
      SomeValues.SomePlus x 7
  \end{minted}
  \caption{A valid FShark program}
  \label{fig:validfsharkprogram}
\end{figure}

\begin{figure}
  \centering
  \begin{minted}{text}
    let Four : i32 = 4i32
    let SomePlus (x : i32) (y : i32) : i32 =
      ((x i32.+ y))
    entry TimesTwo (x : i32) : i32 =
      unsafe SomePlus(x) (x)
    entry MapPlusTwo (xs : []i32) : []i32 =
      unsafe map (let x = 2i32 in
                  (\(y : i32) -> ((x i32.+ y)))) (xs)
    let PlusSeven (x : i32) : i32 =
      SomePlus(x) (7i32)
      \end{minted}
  \caption{A valid FShark program, compiled to Futhark}
  \label{fig:validfsharkprogramresult}
\end{figure}

  
In figure \ref{fig:validfsharkprogram} we see a small but valid FShark program. It
reads like a regular F\# program, but contains the three vital parts that makes
it usable as an FShark program.
\begin{itemize}
\item The module declaration on the first line declares that the following code
  is inside a module. In this case, we are declaring the module
  \texttt{ExampleModule}, although we could use any valid F\# module name.
  As shown in figure \ref{fig:validfsharkprogramresult}, the top module
  declaration falls away during compilation, so only the top module contents are
  left.

\item This \texttt{open} statement ensures that the F\# Compiler Services has
  access to the FSharkPrelude during the compilation. It is possible to write an
  FShark program which doesn't use the FSharkPrelude, but this removes access to
  the SOACs that we use to write our data parallel programs.

\item The \texttt{[<FSharkEntry>]} attributed function \texttt{TimesTwo} ensures
  that the resulting Futhark library from the FShark compiler has at least one
  entry point function.
  Without any entry point functions, we won't have any functions in the final
  compiled FShark program.
\end{itemize}

In figure \ref{fig:validfsharkprogramresult} we see the resulting Futhark program.
For now, we will ignore the transformations that have happened, except for two
things: The \texttt{Map} function (called from FSharkPrelude) has been rewritten
as the plain Futhark SOAC \texttt{map} in lowercase, and the module SomeValues has been
flattened (see sec \ref{futurework:modules} for future plans.)

This Futhark program is then stored in a temporary location in the user's file
system, and compiled into as a library, using Futhark's C\# compiler, either
with or without OpenCL support. Finally after this compilation, we can invoke
the resulting .dll file from within the FShark-using F\# program.

\subsection{Building FShark from the Typed AST}
\label{sec:fsharkcompilerrules}
FShark supports a subset of the F\# language, which also means that only a
subset of F\#'s FSharpExpr

Only the supported FSharpExpr's has been listed here, but the full range of
FSharpExpr's are available on \cite{typedtree}.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis"
%%% End: