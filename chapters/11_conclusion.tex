\chapter{Conclusion and future work}
We have presented a code generator which generates GPU accelerated computational
libraries that are readily integrable in both \csharp{} and \fsharp{} programs.
We have also presented a programming language \fshark{}, which allows us to
prototype, compile and execute GPU kernels in an \fsharp{} environment.

Our benchmarks shows that our \csharp{} code generator generates GPU kernels
which has performance comparable to the GPU kernels generated by the already
existing \clang{} code generator, with average runtimes being within $something$ for
large datasets.
However, multiple test cases in the Futhark test suite are still failing. This
indicates that the current version of the \csharp{} code generator can not
completely Futhark code to \csharp{} programs.

We have validated the \fshark{} language and it's translations to Futhark on a
comprehensive test suite of over NNN tests, which covers the entire \fsharp{} language and it's
standard library.\\
Furthermore we have demonstrated that \fshark{} is suitable for
developing efficient GPU kernels, by porting multiple existing GPU benchmarks to
\fshark{} \--- although currently with severe ($\times 2.5$) speed reductions for large datasets.

\section*{Future work}
As described in section~\ref{sec:currentlimitations}, the current
implementations of our code generator and \fshark{} suite is limited in several
ways. The following prioritized list shows the future work of the \fshark{}
project.
\begin{itemize}
\item The \csharp{} code generator for Futhark is not finished. Although we can
  succesfully compile and run a large majority of the Futhark benchmark suite,
  there are still several benchmarks that fails to run on the current implementation.
  They either fail due to errors in the current implementation, or because they rely on features that
  have not been implemented yet.
  We plainly need to identify and fix these issues.

\item As described in section~\ref{invocationoverhead}, chaining GPU kernel
  calls currently adds an unnecessary overhead. We want to develop an opaque
  array type which merely contains references to already allocated GPU buffers,
  and which aren't copied back from GPU to RAM until strictly necessary.

\item The current version of \fshark{} prohibits certain function types and
  reserves them for the \fshark{} wrapper, as the wrapper needs to handle jagged
  arrays before using them with \csharp{} Futhark functions.
  We are interested in finding a better way of handling this, so we can remove
  this seemingly arbitrary language restriction.
  
\item Section~\ref{sec:fsharkgpubenchmarks} shows that the sequential \csharp{}
  backend is significantly slower than the sequential \clang{} backend. We want to
  determine whether the current implementation contains any easy fixes for
  better performance. This is not a top priority though, as Futhark is primarily
  intended for OpenCL use anyhow.

\item The current iteration of the \fshark{} language lacks several of Futhark's
  language features.
  For example, as seen in section~\ref{subsec:locvolcalib}, we currently have to emulate \texttt{for-}loops by rewriting them into folds instead.
  It should be possible to add equivalent loop semantics to the \fshark{} language,
  but it does require more time and experiments with the \fsharp{} language and -compiler.

\item \fshark{} currently uses jagged arrays to emulate multidimensional
  arrays, even though jagged arrays themselves bring multiple design problems to
  \fshark{}. The primary reason for using the jagged arrays is that they are easy to develop SOACs for.
  In the future we want to develop a library of SOACS for the
  multidimensional array type in \fsharp{}, so we eventually will be able to
  exclude jagged arrays from \fshark{} completely.

\item The current implementation of the \csharp{} code generator generates
  \csharp{} libraries that takes flat array/integer array pairs as arguments,
  when multidimensional arrays are needed.\\
  It is unpleasant for programmers to manually convert their multidimensional (or jagged) arrays
  before calling Futhark library functions.\\
  We want to change the entry functions for Futhark \csharp{} libraries, so they
  can be called with multidimensional or jagged arrays.
  \\
  Alternatively, we can alleviate the problem by making the flattening algorithms from
  section~\ref{sec:convertingarrays} available through the Futhark generated
  \csharp{} programs.

\end{itemize}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis"
%%% End: