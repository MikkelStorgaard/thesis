\chapter{Introduction}
Developers worldwide are, and have always been, on the lookout for increased
computing performance.
Until recently, the increased performance could easily be
achieved through advances within raw computing power, as CPU's had steadily been
doubling their number of on-chip transistors, in rough accordance to Moore's Law (cit√©r
her).

As performance increases in single-CPU design has stalled due to the power
wall\cite{powerwall} (among other things), developers are turning to multi-core
processors instead. As the number of cores increases, so does the number of
active threads available for parallel data processing.

Modern mainstream GPUs can run tens of thousands of threads in
parallel. Modern mainstream CPUs, like the current Ryzen series by AMD, usually
support between 10 and 20 simultaneous threads.
This makes GPUs the optimal target for data-parallel programming.

GPU programming is complicated: GPU-targeting developers must not only
write the computational kernels for the GPUs, but also often manually handle the
memory allocations and -transfers between the main program and the GPU device.
Such difficulties in GPU development, compared to normal (sequential) CPU
development, severely hinders the adaption of GPU programming in general.

Even though most programming languages support GPU programming through various
libraries, there are very solutions that offers GPU programming through high
level programming \-- the users still have to write their own kernels in some
form, and likewise declare their own buffers.

Two mainstream languages which lack high level GPU programming solutions are
\csharp{} and \fsharp{}. 

It is safe to say that there exists plenty of \csharp{} and \fsharp{} projects
in the real world, which could greatly benefit from parallelizing parts of their
algorithms, but current solutions would then demand that those parts in
particular
should be rewritten at least partly as GPU code, depending on the libraries
used. Depending on someone to have non-mainstream GPU coding skills on a
conventional developer team is not feasible, so the benefits from parallelizing
are often left alone in favor of maintaining a more accessible code base.
\clearpage

Currently, there does exist plenty of high level solutions to this problem.
In particular, numerous domain specific languages exists that allows programmers
to solve their domain specific problems in a high level language, and compile it
to standalone GPU accelerated libraries or programs.

Of such DSLs we have for instance:
\begin{itemize}
\item Forma
\item Ebb
\item one more
\end{itemize}

However, DSLs such as these are always either embedded in some host language
(such as Accelerate), or compiled to standalone executable programs. Their
compilers are designed to optimize performance, but rarely to support
interoperability to any significant degree.

Projects like APLtail\cite{apltail} have shown new ways to obtain GPU-accelerated
executables and libraries from source code written in  high level language. APLtail parses
and compiles APL\footnote{more accurately a subset of the APL language} code into redistributable C or Python libraries.

In summary, the hardware for massively parallel programming is widely available.
Furthermore, solutions exists for writing efficient GPU programs in high level
languages, but these have weak interoperability support with mainstream
languages.

\section{What \fshark{} sets out to do}
This thesis takes inspiration from APLtail\cite{apltail}, and creates a solution
that lets users compile efficient GPU programs from a high level programming
language, whilst at the same time supporting a high level of interoperability
with a mainstream language.
Whereas APLtail allows integration of GPU Futhark-written computation kernels in
C- and Python programs (by means of code generation), we would like to use code generation to make Futhark-written kernels available for use in \csharp{} and \fsharp{} programs.

To show that this is feasible, we first design a \csharp{} code generator for the
Futhark compiler. This code generator must be able to generate \csharp{} source
files, that can be compiled and used either as standalone executables, or as
importable libraries in any other \csharp{} or \fsharp{} program.
There were several notable challenges in this process, namely 1) designing
\csharp{} programs that could encapsulate entire Futhark programs in a single
class, and 2) designing helper libraries to include in the generated code, and
3) designing a way to write sequential (non-GPU) Futhark code as pure \csharp{},
in cases where GPU devices are unavailable.

The code generator alone should not convince anyone that we are creating GPU
kernels from a high level language, which is why we also design and implement a
compiler which takes source code written in a mainstream language, compiles it
as efficient GPU kernels, and (together with the code generator) makes the
resulting GPU program immediately operable from the mainstream language itself.  
The main challenges for this was 1) identifying which parts of the \fsharp{}
language that were suitable for Futhark translation, 2) implementing a standard
library for Futhark targeted \fsharp{} programs, and 3) designing and implementing a compiler
pipeline that would let users program and use GPU kernels in \fsharp{}, without
manually using Futhark compilers or importing external libraries.

Empirical evaluation demonstrates that this approach is feasible.
We both show that that unit tests written in a high level language can be compiled and executed
correctly as computational kernels on the GPU, just as we also take complex
benchmark programs written in a mainstream language, compile them into
computational kernels for the GPU, and use them directly in the mainstream
language afterwards.

\clearpage

\section*{The contributions of this thesis}
The contributions of this thesis are as follows:
\begin{enumerate}
\item A \csharp{} code generator for the Futhark language compiler, which
  generates GPU accelerated libraries that can integrate seamlessly in 
  \csharp{} and \fsharp{} code bases.

\item A select subset of the \fsharp{} langauge which can be translated directly to
  Futhark source code of equivalent functionality. This includes a
  library which implements Futhark SOACs\cite{soacs} in \fsharp{}, allowing
  people to write \fsharp{} code which can be ported automatically to Futhark.

\item A compiler and wrapper pipeline which allows users to compile individual
  \fsharp{} modules in their projects to GPU accelerated libraries, and load and
  execute code from these modules in the rest of the \fsharp{} project.

\item A set of benchmarks and unit tests that shows that this approach is indeed feasible.
\end{enumerate}

\clearpage
\section*{Vocabulary}
Unless otherwise specified, these are the terms used in the thesis:
\begin{description}
\item[For \fshark{}]\hfill
  \begin{itemize}
  \item The \fshark{} \textit{subset} is the subset of the \fsharp{} language
    that is supported by the \fshark{} compiler.

  \item The FShark Prelude is the library of \fsharp{}-ported Futhark array
    functions and SOACs, and is included with \fshark{}.

  \item \fshark{} code is \fsharp{} code which exclusively uses the \fshark{}
    subset and FSharkPrelude.

  \item \fshark{} modules are \fsharp{} modules written entirely in \fshark{}
    code.
    
  \item \fshark{} projects are \fsharp{} projects which uses \fshark{} and
    \fshark{} modules.
    \\
  \end{itemize}

\item[For Futhark]\hfill
  \begin{itemize}

  \item Futhark code is code written in Futhark.

  \item Futhark C-, Python- or \csharp{} code refers to Futhark code that has been compiled
    into C-, Python or \csharp{} source code.

  \end{itemize}
\end{description}



\section*{Roadmap}
The main part of this thesis is split in four parts.
blaaaah


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis"
%%% End: