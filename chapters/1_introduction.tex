\chapter{Introduction}
Developers worldwide are, and have always been, on the lookout for increased
computing performance.
Until recently, the increased performance could easily be
achieved through advances within raw computing power, as CPU's had steadily been
doubling their number of on-chip transistors, in rough accordance to Moore's Law (cit√©r
her).

As performance increases in single-CPU design has stalled due to the power
wall\cite{powerwall} (among other things), developers are turning to multi-core
processors instead. As the number of cores increases, so does the number of
active threads available for parallel data processing.

Modern mainstream GPUs can run tens of thousands of threads in
parallel. Modern mainstream CPUs, like the current Ryzen series by AMD, usually
support between 10 and 20 simultaneous threads.
This makes GPUs the optimal target for data-parallel programming.

GPU programming is complicated: GPU-targeting developers must not only
write the computational kernels for the GPUs, but also often manually handle the
memory allocations and -transfers between the main program and the GPU device.
Such difficulties in GPU development, compared to normal (sequential) CPU
development, severely hinders the adaption of GPU programming in general.

Even though most programming languages support GPU programming through various
libraries, there are very solutions that offers GPU programming through high
level programming \-- the users still have to write their own kernels in some
form, and likewise declare their own buffers.

Two mainstream languages which lack high level GPU programming solutions are
\csharp{} and \fsharp{}. 

It is safe to say that there exists plenty of \csharp{} and \fsharp{} projects
in the real world, which could greatly benefit from parallelizing parts of their
algorithms, but current solutions would then demand that those parts in
particular
should be rewritten at least partly as GPU code, depending on the libraries
used. Depending on someone to have non-mainstream GPU coding skills on a
conventional developer team is not feasible, so the benefits from parallelizing
are often left alone in favor of maintaining a more accessible code base.
\clearpage

Currently, there does exist plenty of high level solutions to this problem.
In particular, numerous domain specific languages exists that allows programmers
to solve their domain specific problems in a high level language, and compile it
to standalone GPU accelerated libraries or programs.

Of such DSLs we have for instance:
\begin{itemize}
\item Forma
\item Ebb
\item one more
\end{itemize}

However, DSLs such as these are always either embedded in some host language
(such as Accelerate), or compiled to standalone executable programs. Their
compilers are designed to optimize performance, but rarely to support
interoperability to any significant degree.

Projects like APLtail\cite{apltail} have shown new ways to obtain GPU-accelerated
executables and libraries from source code written in  high level language. APLtail parses
and compiles APL\footnote{more accurately a subset of the APL language} code into redistributable C or Python libraries.

In summary, the hardware for massively parallel programming is widely available.
Furthermore, solutions exists for writing efficient GPU programs in high level
languages, but these have weak interoperability support with mainstream
languages.

\section{What \fshark{} sets out to do}
This thesis takes inspiration from APLtail\cite{apltail}, and creates a solution
that lets users compile efficient GPU programs from a high level programming
language, whilst at the same time supporting a high level of interoperability
with a mainstream language.
Whereas APLtail allows integration of GPU Futhark-written computation kernels in
C- and Python programs (by means of code generation), we would like to use code generation to make Futhark-written kernels available for use in \csharp{} and \fsharp{} programs.

To show that this is feasible, we first design a \csharp{} code generator for the
Futhark compiler. This code generator must be able to generate \csharp{} source
files, that can be compiled and used either as standalone executables, or as
importable libraries in any other \csharp{} or \fsharp{} program.
MERE HER

The code generator alone should not convince anyone that we are creating GPU
kernels from a high level language, which is why we also design and implement a
compiler which takes source code written in a mainstream language, compiles it
as efficient GPU kernels, and (together with the code generator) makes the
resulting GPU program immediately operable from the mainstream language itself.  

Empirical evaluation demonstrates that this approach is feasible.
We both show that that unit tests written in a high level language can be compiled and executed
correctly as computational kernels on the GPU, just as we also take complex
benchmark programs written in a mainstream language, compile them into
computational kernels for the GPU, and use them directly in the mainstream
language afterwards.































\section*{Motivation}
\fshark{} is intended to be a way of writing and utilizing Futhark, without
actually having to write or interact with the Futhark language and compiler
itself. Besides some tooling and an \fsharp{} SOAC library, it primarily consists of the \fshark{} compiler that compiles from
\fsharp{} source code to Futhark source code, and the Futhark \csharp{}
generator, which compiles Futhark programs as either standalone \csharp{}
programs or -libraries.

As much as most developers are happy to increase performance on big
computations, it is not always an option to incorporate an extra langauge into
an already existing programming language. At this moment, using Futhark in
either a \csharp{}- or \fsharp{} project is a contrived process that usually
requires spawning a subprocess with a \texttt{futhark-opencl} C program from inside one of the .NET
projects.

In order to use Futhark natively in .NET languages, it is therefore
necessary to write a backend for Futhark in a .NET language.
For \fshark{}, I have chosen to implement this backend in \csharp{}, as the Futhark intermediate
code \texttt{ImpCode}\footnote{which stands for Imperative Code} is trivial to
translate into imperative \csharp{} statements and expressions.
Also, there are \csharp{} libraries available which supply OpenCL bindings, which are
needed to implement the necessary OpenCL constructs from \texttt{ImpCode}.

It is my belief that exporting Futhark programs as .NET executables and
-libraries will lower the barrier to Futhark usage in .NET projects
significantly, hopefully increasing the all-round number of Futhark users, and
in the long term, increasing utilization of GPU programming and making it more
widely available.

However, one could do even more than just exporting Futhark to .NET, to increase
accessibility:

As tens of thousands of programmers worldwide (CHECK NUMBER JEEEEZ) are already
writing \fsharp{} programs, and that most of \fsharp{}s functional language features can be
directly translated into equivalent Futhark features, it became worthwhile to
investigate whether it was possible to design a way for users to both write and
utilize Futhark in \fsharp{} projects, without ever actually touching the
Futhark language or compiler themselves.
Instead, users can write their data parallel \fsharp{} modules in \fshark{}, and compile these
modules into Futhark libraries automatically.

In this case, it would be possible to get Futhark speeds in \fsharp{} programs,
without doing much more than installing the Futhark compiler locally, and adding
the required \fshark{} libraries to the \fsharp{} project.

It is my belief that being able to achieve Futhark performance in regular \fsharp{}
programs almost automatically, will make it significantly easier for people to
adapt to Futhark programming.

(SOME MORE MORE SOME MORE)

\clearpage
\section*{The contributions of this thesis}
The contributions of this thesis are as follows:
\begin{enumerate}
\item The \texttt{FSharkPrelude}:\\
  The \texttt{FSharkPrelude} is a subset of the Futhark SOACs, ported to
  \fsharp{}. To write an \fshark{} program, the user is directed to limit
  himself to the SOACs in the \texttt{FSharkPrelude}. This means exchanging
  \texttt{Array.map} for \texttt{FSharkPrelude.Map}, \texttt{Array.foldBack} for
  \texttt{FSharkPrelude.foldr}, and so on.
  However, the \texttt{FSharkPrelude} carries the guarantee, that all
  \texttt{FSharkPrelude} functions works equivalently to their Futhark SOAC namesakes. 
  This prelude, together with the \fsharp{} subset chosen for \fshark{}, makes
  it possible to write \fsharp{} programs which, when translated to Futhark
  code, are equivalent to their Futhark counterparts.

\item An \fsharp{} subset translatable with \fshark{}:\\
  As \fsharp{} is not only a multi-paradigm language, but also has access to the
  entire standard .NET library, it was required to make \fshark{} support only a
  subset of \fsharp{}. This has been implemented by whitelisting only the
  \fsharp{}-to-Futhark translatable types, constructs and expressions in the \fshark{}
  compiler. Furthermore, no other module imports than \texttt{FSharkPrelude} are allowed. 
  This subset is of course documented for users.

\item The \fshark{} Compiler and Wrapper:\\
  The \fshark{} Compiler and Wrapper takes a module written in \fshark{} as
  input, converts the \fshark{} module into a compiled Futhark \csharp{} module,
  and makes it available to the \fsharp{} program, all at runtime.
  The pipeline is described in sec \ref{chapter:fsharkcompiler}

\item A \csharp{} backend for Futhark:\\
  To actually use Futhark in \csharp{} projects (and transitively \fsharp{}
  projects), it was necessary to develop and add a \csharp{} backend to
  the Futhark compiler. This backend is equivalent in functionality to
  the \texttt{C}- and the \texttt{Python} backends that are already available.

\end{enumerate}

\clearpage
\section*{Vocabulary}
Unless otherwise specified, these are the terms used in the thesis:
\begin{description}
\item[For \fshark{}]\hfill
  \begin{itemize}
  \item The \fshark{} \textit{subset} is the subset of the \fsharp{} language
    that is supported by the \fshark{} compiler.

  \item The FShark Prelude is the library of \fsharp{}-ported Futhark array
    functions and SOACs, and is included with \fshark{}.

  \item \fshark{} code is \fsharp{} code which exclusively uses the \fshark{}
    subset and FSharkPrelude.

  \item \fshark{} modules are \fsharp{} modules written entirely in \fshark{}
    code.
    
  \item \fshark{} projects are \fsharp{} projects which uses \fshark{} and
    \fshark{} modules.
    \\
  \end{itemize}

\item[For Futhark]\hfill
  \begin{itemize}

  \item Futhark code is code written in Futhark.

  \item Futhark C-, Python- or \csharp{} code refers to Futhark code that has been compiled
    into C-, Python or \csharp{} source code.

  \end{itemize}
\end{description}



\section*{Roadmap}
The main part of this thesis is split in four parts.
blaaaah


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis"
%%% End: